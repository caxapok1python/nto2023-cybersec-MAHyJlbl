# Web
## Task 2
В функции make_request идет GET запрос на второй сервер(ip:3001), что наводит на мысль о возможности загрузки username, данными такого вида, чтобы можно было провизветси атаку через поломку отправки данных.Полезная нагрузка выглядел следющим образом:
username={testoviy_username}\r\n
\r&password={testoviy_password}

После регистрации c использованием данной нагрузки мы получил session.cid, который был передан в login, после чего в основной функции был запрошен make_request, что выдаёт ошибку содержащую искомый флаг.


## Task 3
В файле исходного кода index.js используется проверка req.isLocalRequest. В коде сайта обратили внимание на функцию /pollute/:param/:value, изучив ее, мы двинулись дальше в основную функцию проверки /admin/*, там, изучив запрашиваемые данные мы поняли, что, по запрашиваемым данным, нам требуется изменить параметр userProperty и придать ему значени isLocalRequest. 

# Crypto
## Task 1
Можно заметить, что каждый символ всегда шифруется в одно и то же значение с помощью функции в коде, поэтому можно завести словарь, сделать перебор по всем ASCII кодам, и для каждого записать в словарь ключ - зашифрованное значение, значение - сам символ. Затем с помощью этого словаря можно расщифровать все значения из файла с паролем.

## Task 2
Заранее запишем число n. При отправке get запроса с существующим индексом i мы получаем число, назовем его k_i. Если k_i < n//2, то i-ый бит точно равен 1, иначе может быть или 0 или 1. Тогда можно отправлять нескольлко запросов на один и тот же индекс i, и при достаточном количестве запросов можно понять какой бит находится на i-ом месте: если для всех запросов n//2 <= k_i <= n, то i-ый бит равевн 0, иначе 1. Можно доказать, что при 15 get запросах для каждого i, вероятность того что все биты будут определены верно > 99%. После этого можно перевести полученное число из двоичной системы счисления в десятичную и получить флаг с помощью long_to_bytes.

# Reverse
## Task 1
C помощью команды file выесняем, что файл имеет расширение dos. Делаем тестовый запуск при помощи утилиты dosbox, в результате делаем вывод что каждый символ выводимого флага пишется в некоторую велечину времени дольше предыдущего.
С помощь утилиты cutter прооизводим декомпиляцию файла и последующий анализ кода, в результате которого понимаем, что увеличение времени в цикле зависит от строки с значением int 0х15. С целью пропустить данную часть кода, патчим ее, заменяя описанную строку на nop и экспортировав новый код в виде исполняемого файла, снова запускаем его при помощи утилиты dosbox. Результат вывполнения данного кода возвращает искомый флаг.


# Forensic
## Machine 1
### Task 1
При запуске файла minecraft.jar открывается реверсшел, написаный на java(minecraft.jar/Malware/ReverseShell.class). Таким образом злоумышленник получил удалённый доступ к машине жертвы.

### Task 2 
Злоумышленник скачал linpeas.sh и для получения информации о find. И эксплуатиривал find для получения прав суперпользователя

### Task 3
Злоумышленник установил кейлогепр на компьютер жертвы и дождался пока жертва введет пароль.

### Task 4
В процессе просмотра системы мы установили, что logkeys считывает нажатые клавиши с компьютера жертвы в файл /var/log/logkeys.log

### Task 5
passwords.md это файл с паролями для менеджера KeePass, пароль к которому получил злоумышленник с помощью кейлогера. Внутри содержится пароль для доступа к windows-rdp.


